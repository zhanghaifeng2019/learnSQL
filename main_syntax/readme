心得: select 后面跟的都是column名。


1.SHOW DATABASES;


2.CREATE DATABASE database_name;


3.USE database_name;


//能为null的，全都设为null 这样可以减轻数据库负担。

4.
CREATE TABLE agencyinfo(
    id INT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,
    agency_name VARCHAR(255) COLLATE utf8_general_ci DEFAULT NULL,
    person_in_charge VARCHAR(255) COLLATE utf8_general_ci　DEFAULT NULL,
    tel VARCHAR(255) COLLATE utf8_general_ci DEFAULT NULL,
    email VARCHAR(255) COLLATE utf8_general_ci DEFAULT NULL,
    zip VARCHAR(8) COLLATE utf8_general_ci DEFAULT NULL,
    address VARCHAR(255) COLLATE utf8_general_ci DEFAULT NULL,
    is_deleted TINYINT(1) NOT NULL DEFAULT 0,
    created DATETIME,
    modified DATETIME
)ENGINE=InnoDB DEFAULT CHARSET=utf8;



5.
//不包含id,插入所有column。可插入多条数据，也可插入一条数据

INSERT INTO table_name 
VALUE ('ハナコ',27), 
("1",'アン',34), 
("2",'オシン',52), 
("3",'ジュン',25), 
("4",'エリー',22);


//只插入type 跟 price 两个column

INSERT INTO table_name (type, price)
VALUE ('ハナコ',27), 
('アン',34), 
('オシン',52), 
('ジュン',25), 
('エリー',22);


6,
SELECT * FROM table_name;

SELECT column1,column2 FROM table_name;

SELECT column1,column2 FROM table_name  WHERE id=1;                  (id 为 int 型)

SELECT column1,column2 FROM table_name  WHERE name="zhanghaifeng";   (name 为 varchar 型)


7，
UPDATE table_name  SET column_name="~~~" WHERE id=1;

UPDATE table_name  SET column_name1="~~~",column2="~~~" WHERE id=1;

8,

DELETE FROM table_name
DELETE FROM table_name WHERE id=1;
DELETE FROM table_name WHERE name="zhanghaifeng";

9,
desc table_name;


10,
DROP TABLE table_name;


11,
DROP DATABASES database_name;


12, 通过导入文件来建立表单
source path/file_name.sql;



----------------------------------------------------------------------------------
string function  不怎么用

13,  CONCAT()

SELECT CONCAT(first_name,last_name) AS "full_name" FROM table_name;

SELECT CONCAT(first_name,"-",last_name) AS "full_name" FROM table_name;

SELECT CONCAT_WS("-",title,name,age) AS "bookinfo" FROM table_name;                   => title-name-age


14,   SUBSTRING()

SELECT SUBSTRING("hello world",1,4);   1开始，4结束   =>hell


SELECT SUBSTRING("hello world",7);     7开始         =>world



15 ,
SELECT CONCAT
       (
         SUBSTRING(title,1,10),
         "......."
       ) AS "short_title"
       FROM books ;                     截取一部份title并在其后加上省略号 => he is a......
      

16,REPLACE

SELECT REPLACE("hello,world","hello","good");  => "good,world"

SELECT REPLACE(title,"e","t")FROM books;       将title里的e全部换成t


17，REVERSE

SELECT REVERSE(title) FROM books;


18,CHAR_LENGTH

SELECT CHAR_LENGTH("hello");

SELECT title,CHAR_LENGTH(title) AS length FROM books;




19,UPPER <=> LOWER

SELECT UPPER("hello,world");   =>HELLO,WORLD

-----------------------------------------------------------------------------------------------------------------

20,DISTINCT

SELECT DISTINCT title FROM books;

SELECT DISTINCT fname,lname FROM books;

fname     lname

zhang    haifeng         zhang haifeng
zhang    haifeng      => wang  ming
wang     ming            li    wei 
li       wei


21,ORDER BY

SELECT fname FROM books ORDER BY fname;   =>按字母顺序,数字也可以排

SELECT fname FROM books ORDER BY fname DESC; =>字母逆序

SELECT fnam,age FROM books ORDER BY age ;

SELECT fnam,age FROM books ORDER BY 2 ;   2指的age，与上面的命令相同。

SELECT fname,lname FROM books ORDER BY  fname,lname;   首先fname按顺序排列，如果fname中有两个值相同，就按lname的顺序来排。


22,LIMIT -> pagination

SELECT title FROM books LIMIT 5;  取五条记录

SELECT title FROM books LIMIT 0,10;  从第一行开始选，选10个


23，LIKE  ->  search
SELECT title,author_fname FROM books WHERE author_name LIKE "da";    搜索author_name里面包含da的字符，不管大小写
SELECT title,author_fname FROM books WHERE author_name LIKE "____";  这里的四个下划线，表示四个字符。搜索author_name里面只有四个字符的记录。

字符逃跑 \%, \_
WHERE title LIKE "%\%%"
WHERE title LIKE "%\_%"




--------------------------------------------------------------------------------

aggregate function 集計関数

24, COUNT();  计算有多少条记录

SELECT COUNT(*) FROM books;
SELECT COUNT(DISTINCT fname,lname )FROM books;   排除同名的，求记录的数量。
SELECT COUNT(*) FROM books WHERE title LIKE "%the%" ;    计算title 包含the的数量



25，GROUP BY();

SELECT author_name,age FROM books GROUP BY author_name;

author_name   age       author_name   age         
zhang         10           zhang      10     =>  zhang      10       zhang      20  这是一组，第二个以后被隐藏了
zhang         20           wang       15     =>  wang       1        wang       25  这是另一组，第二个以后被隐藏了
wang          15    =>     huang      30
wang          25
huang         30


SELECT author_name,COUNT(*) FROM books GROUP BY author_name;　　　先按姓名分组，再 计算没一组的数量

author_name   COUNT(*)
zhang     　　 2
wang       　　2
huang      　　1


SELECT fname,lname,COUNT(*) FROM books GROUP BY fname, lname;   

按fname 和 lname来分，必须是两个人的fname和lname相同还能分到同一组。否则分到不同组。


SELECT CONCAT("released_year"," ",COUNT(*),"book(s) released") FROM books GROUP BY released_year;

=> 2003 3 book(s) released;     如果后面跟了GROUP BY 从句，那么COUNT(*) 计算的是每一组的数量



26，MAX(),MIN()
SELECT MIN(age)　FROM books;

查找，页数最多的书名。
SELECT MAX(pages)，title FROM boosk; 这样写是错的。MAX(pages)只有一行，然后再选title的时候，数据库就会只选第一个title。

方法一:用子句，因为要运行两个句子，所以查询速度慢。

SELECT pages,title FROM books WHERE pages = (SELECT MAX(pages) FROM books);

方法二: 用order by

SELECT pages,title FROM books ORDER BY pages DESC LIMIT 1;


27，find the year each author published their first book;  each  找到每一个作者第一次出版书的时间。
    数据库语言要从后忘前看
    
    SELECT author_fname,author_lname,MIN(released_year) FROM books  GROUP BY author_fname,author_lname;
    首先按author_fname,author_lname分组，然后再去取每个组里面的MIN(released_year)，author_fname,author_lname;
    
    SELECT CONCAT(author_fname,"",author_lname) AS author,MAX(pages) AS "longest book" 
    FROM books 
    GROUP BY author_fname,author_lname;

28, SUM()

SELECT SUM(age) FROM books;   把所有的页数都加起来。只有一个值。
SELECT author_fname,author_lname,SUM(pages) FROM books GROUP BY author_fname,author_lname;


29,AVG()
SELECT AVG(age) FROM books; 求平均，把所有记录的age相加，除以记录数，只有一个值.

后面也可跟group by ,跟 max，min，sum,count 一样

SELECT author_fname,author_lname,AVG( pages) FROM books GROUP BY author_fname,author_lname;


-------------------------------------------------------------------------------------------------
data types

详见database.doc 文件


-------------------------------------------------------------------------------------------------
logical charact
！=
NOT LIKE
>
<
=
>=
<= 
AND(也可以写成&&)
OR(也可以写成||)

BETWEEN
NOT BETWEEN 
SELECT title FROM books WHERE released_year BETWEEN 2001 AND 2010; (released_year>=2001 AND released_year<=2010)
SELECT title FROM books WHERE released_year NOT BETWEEN 2001 AND 2010;(released_year<2001 AND released_year>2010)

"2017-05-02"  是一个string。
CAST("2017-05-02" AS DATETIME) 就变成了一个 DATETIME 类型了 ;SELECT CAST("2017-05-02" AS DATETIME);    =>2017-05-02 00:00:00
CAST("2017-05-02" as DATE)
SELECT name,birthdt FROM people WHERE birthdt BETWEEN "2010-01-01" AND "2000-01-01";   依然会有结果但是不建议这样用。
SELECT name,birthdt FROM people WHERE birthdt BETWEEN CAST("2010-01-01" AS DATETIME) AND CAST("2000-01-01" AS DATETIME);




IN
SELECT title,author_lname FROM books WHERE author_lname IN( "zhang","wang","li");                                 这个更短，更有用。
=
SELECT title,author_lname FROM books WHERE author_lname="zhang" OR author_lname="wang" OR author_lname="li";      这个太长不好维护


NOT IN 
SELECT title,released_year FROM books WHERE  released_year NOT IN(2000,2001,2002);  
=
SELECT title,released_year FROM books WHERE released_year != 2000 AND released_year != 2001 ANDreleased_year != 2002;

SELECT title,released_year FROM books WHERE released_year>=2000 released_year NOT IN(2000,2001,2002,2003,2004 );  


CASE

books表里面没有genre这一栏，我想出版年大于2000 显示genre为mordern literature，否则显示为20th century literature

SELECT title,released_year,
       CASE
         WHEN released_year >= 2000 THEN "mordern literature"
         ELSE "20th century literature"
       END AS GENRE
FROM books;


用星号表示存货充足与否
 
SELECT title,stock_quantity 
      CASE 
          WHEN stock_quantity BETWEEN 0 AND 50 THEN "*"
          WHEN stock_quantity BETWEEN 51 AND 100 THEN "**"
          ELSE "***" 
      END AS stock
FORM books;
      



select.....from..... where...AND...x like... order by.....limit   最先看join 再看 group by 再看where
select.....from..... where...AND...x like...group by.....limit

